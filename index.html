<!doctype html>
<html>
  <head>
    <meta charset = 'utf-8'>
    
    <title>HTML5 Fancy Clock</title>
    
    <meta name = 'viewport' content = 'width=device-width, initial-scale=1.0'>
    
    <style>
      /* general declarations */
      
      html, body, body *:not(script, table, thead, tbody, tr, th, td) {
        display: flex;
        flex-direction: column;
        align-items: stretch;
        justify-content: stretch;
        flex-grow: 1;
        flex-shrink: 1;
        min-height: 0;
      }
      
      html {
        height: 100%;
      }
      
      body {
        margin: 0;
      }
      
      #canvas {
        background-color: black;
      }
    </style>
  </head>
  <body>
    <canvas id = 'canvas'></canvas>
    
    <script>
      // constants to change program operation
      let LOG_DEBUG = false;
      let CLOCK_DRAW_MODE = '24hr';
      
      // sets canvas pixel width and height to its css width and height
      function resetCanvasSize() {
        let canvasStyle = getComputedStyle(canvas);
        
        let canvasWidth = parseInt(canvasStyle.width);
        let canvasHeight = parseInt(canvasStyle.height);
        
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
      }
      
      // draws text to screen per letter, spaced using the letterSpacings array
      function drawTextWithPerLetterSpacing(ctx, text, centerX, centerY, letterSpacings) {
        // calculate cumulative version of letterSpacings array
        let letterSpacingsCumulative = letterSpacings.reduce((a, c) => {
          a.push(a.length == 0 ? c : a[a.length - 1] + c);
          return a;
        }, []);
        
        // calculate offset from centerX all letters will be drawn from
        let centerXOffset = (letterSpacingsCumulative[0] + letterSpacingsCumulative[letterSpacingsCumulative.length - 1]) / 2 * -1;
        
        // draw spaced letters
        for (let i = 0; i < text.length; i++) {
          ctx.fillText(text[i], centerX + centerXOffset + letterSpacingsCumulative[i], centerY);
        }
      }
      
      // draws clock onto canvas
      function renderFrame(forceRerender) {
        // get current date
        let now = new Date();
        
        // only rerender if seconds changed or force rerender
        if ((now.getSeconds() != oldSecondsValue) || forceRerender) {
          // get context
          let ctx = canvas.getContext('2d');
          
          // clear canvas
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          
          switch (CLOCK_DRAW_MODE) {
            case 'normal':
              {
                // TODO
              }
              break;
            
            case '24hr':
              {
                // print title at top of screen
                ctx.fillStyle = 'white';
                ctx.font = `10vh sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('24-Hour Time', canvas.width / 2, canvas.height * 0.08);
                
                // draw clock
                // > define variables
                let clockCenterX = canvas.width / 2;
                let clockCenterY = canvas.height * 0.5;
                let clockRadius = canvas.height * 0.32;
                
                // > outer circle
                ctx.strokeStyle = 'white';
                ctx.lineWidth = canvas.height * 0.002;
                ctx.beginPath();
                ctx.arc(clockCenterX, clockCenterY, clockRadius, 0, Math.PI * 2);
                ctx.stroke();
                
                // > inward lines at each hour
                ctx.beginPath();
                for (let i = 0; i < 24; i++) {
                  let angle = Math.PI * 2 / 24 * i - Math.PI / 2;
                  
                  let normalizedX = Math.cos(angle);
                  let normalizedY = Math.sin(angle);
                  
                  ctx.moveTo(
                    clockCenterX + normalizedX * clockRadius * 0.85,
                    clockCenterY + normalizedY * clockRadius * 0.85
                  );
                  ctx.lineTo(
                    clockCenterX + normalizedX * clockRadius,
                    clockCenterY + normalizedY * clockRadius
                  );
                }
                ctx.stroke();
                
                // > text at each hour
                for (let i = 0; i < 24; i++) {
                  let angle = Math.PI * 2 / 24 * i - Math.PI / 2;
                  
                  let normalizedX = Math.cos(angle);
                  let normalizedY = Math.sin(angle);
                  
                  let hourTextHeight = 2; // units of vh
                  ctx.fillStyle = 'white';
                  ctx.font = `${hourTextHeight}vh sans-serif`;
                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'middle';
                  drawTextWithPerLetterSpacing(
                    ctx, (i + '').padStart(2, '0') + '00',
                    clockCenterX + normalizedX * clockRadius * 0.75,
                    clockCenterY + normalizedY * clockRadius * 0.75,
                    [
                      0,
                      canvas.height * hourTextHeight / 100 * 0.55,
                      canvas.height * hourTextHeight / 100 * 0.55,
                      canvas.height * hourTextHeight / 100 * 0.55,
                    ]
                  );
                }
                
                // > green external triangle on the current time
                {
                  // a continuous version of hours that smoothly increases over time
                  let smoothedHours = now.getHours() + now.getMinutes() / 60 + now.getSeconds() / 3600;
                  
                  let angleCenter = Math.PI * 2 / 24 * smoothedHours - Math.PI / 2;
                  let angleLeft = angleCenter - Math.PI * 2 / 24 * 0.3;
                  let angleRight = angleCenter + Math.PI * 2 / 24 * 0.3;
                  
                  ctx.fillStyle = 'green';
                  ctx.beginPath();
                  ctx.moveTo(
                    clockCenterX + Math.cos(angleLeft) * clockRadius * 1.13,
                    clockCenterY + Math.sin(angleLeft) * clockRadius * 1.13,
                  );
                  ctx.lineTo(
                    clockCenterX + Math.cos(angleRight) * clockRadius * 1.13,
                    clockCenterY + Math.sin(angleRight) * clockRadius * 1.13,
                  );
                  ctx.lineTo(
                    clockCenterX + Math.cos(angleCenter) * clockRadius * 1.01,
                    clockCenterY + Math.sin(angleCenter) * clockRadius * 1.01,
                  );
                  ctx.fill();
                }
                
                // calculate string for time
                let timeString =
                  (now.getHours() + '').padStart(2, '0') + ':' +
                  (now.getMinutes() + '').padStart(2, '0') + ':' +
                  (now.getSeconds() + '').padStart(2, '0');
                
                // print time below clock
                let timeTextHeight = 10; // units of vh
                ctx.fillStyle = 'white';
                ctx.font = `${timeTextHeight}vh sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                drawTextWithPerLetterSpacing(
                  ctx, timeString, canvas.width / 2, canvas.height * 0.92,
                  [
                    0,
                    canvas.height * timeTextHeight / 100 * 0.55,
                    canvas.height * timeTextHeight / 100 * 0.4,
                    canvas.height * timeTextHeight / 100 * 0.4,
                    canvas.height * timeTextHeight / 100 * 0.55,
                    canvas.height * timeTextHeight / 100 * 0.4,
                    canvas.height * timeTextHeight / 100 * 0.4,
                    canvas.height * timeTextHeight / 100 * 0.55,
                  ]
                );
              }
              break;
          }
          
          oldSecondsValue = now.getSeconds();
        }
        
        // queue next frame render
        requestAnimationFrame(renderFrameCallback);
      }
      
      // render frame callback used by requestAnimationFrame, this is done to ignore args passed in by requestAnimationFrame
      function renderFrameCallback() {
        renderFrame();
      }
      
      // global variables
      let oldSecondsValue = null;
      
      // register event listeners
      addEventListener('load', () => {
        if (LOG_DEBUG) console.debug('load');
        resetCanvasSize();
        renderFrame(true);
      });
      
      addEventListener('resize', () => {
        if (LOG_DEBUG) console.debug('resize');
        resetCanvasSize();
        renderFrame(true);
      });
    </script>
  </body>
</html>
